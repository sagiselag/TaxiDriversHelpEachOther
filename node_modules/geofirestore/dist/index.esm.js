const BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';
const BITS_PER_CHAR = 5;
const E2 = 0.00669447819799;
const EARTH_EQ_RADIUS = 6378137.0;
const EARTH_MERI_CIRCUMFERENCE = 40007860;
const EPSILON = 1e-12;
const GEOHASH_PRECISION = 10;
const MAXIMUM_BITS_PRECISION = 22 * BITS_PER_CHAR;
const METERS_PER_DEGREE_LATITUDE = 110574;
function boundingBoxBits(coordinate, size) {
    const latDeltaDegrees = size / METERS_PER_DEGREE_LATITUDE;
    const latitudeNorth = Math.min(90, coordinate.latitude + latDeltaDegrees);
    const latitudeSouth = Math.max(-90, coordinate.latitude - latDeltaDegrees);
    const bitsLat = Math.floor(latitudeBitsForResolution(size)) * 2;
    const bitsLongNorth = Math.floor(longitudeBitsForResolution(size, latitudeNorth)) * 2 - 1;
    const bitsLongSouth = Math.floor(longitudeBitsForResolution(size, latitudeSouth)) * 2 - 1;
    return Math.min(bitsLat, bitsLongNorth, bitsLongSouth, MAXIMUM_BITS_PRECISION);
}
function boundingBoxCoordinates(center, radius) {
    const latDegrees = radius / METERS_PER_DEGREE_LATITUDE;
    const latitudeNorth = Math.min(90, center.latitude + latDegrees);
    const latitudeSouth = Math.max(-90, center.latitude - latDegrees);
    const longDegsNorth = metersToLongitudeDegrees(radius, latitudeNorth);
    const longDegsSouth = metersToLongitudeDegrees(radius, latitudeSouth);
    const longDegs = Math.max(longDegsNorth, longDegsSouth);
    return [
        toGeoPoint(center.latitude, center.longitude),
        toGeoPoint(center.latitude, wrapLongitude(center.longitude - longDegs)),
        toGeoPoint(center.latitude, wrapLongitude(center.longitude + longDegs)),
        toGeoPoint(latitudeNorth, center.longitude),
        toGeoPoint(latitudeNorth, wrapLongitude(center.longitude - longDegs)),
        toGeoPoint(latitudeNorth, wrapLongitude(center.longitude + longDegs)),
        toGeoPoint(latitudeSouth, center.longitude),
        toGeoPoint(latitudeSouth, wrapLongitude(center.longitude - longDegs)),
        toGeoPoint(latitudeSouth, wrapLongitude(center.longitude + longDegs)),
    ];
}
function calculateDistance(location1, location2) {
    validateLocation(location1);
    validateLocation(location2);
    const radius = 6371;
    const latDelta = degreesToRadians(location2.latitude - location1.latitude);
    const lonDelta = degreesToRadians(location2.longitude - location1.longitude);
    const a = Math.sin(latDelta / 2) * Math.sin(latDelta / 2) +
        Math.cos(degreesToRadians(location1.latitude)) *
            Math.cos(degreesToRadians(location2.latitude)) *
            Math.sin(lonDelta / 2) *
            Math.sin(lonDelta / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return radius * c;
}
function decodeGeoQueryDocumentSnapshotData(data, center) {
    if (validateGeoDocument(data, true)) {
        const distance = center ? calculateDistance(data.g.geopoint, center) : null;
        return { data: () => data, distance };
    }
    return { data: () => data, distance: null };
}
function degreesToRadians(degrees) {
    if (typeof degrees !== 'number' || isNaN(degrees)) {
        throw new Error('Error: degrees must be a number');
    }
    return (degrees * Math.PI) / 180;
}
function encodeGeohash(location, precision = GEOHASH_PRECISION) {
    validateLocation(location);
    if (typeof precision === 'number' && !isNaN(precision)) {
        if (precision <= 0) {
            throw new Error('precision must be greater than 0');
        }
        else if (precision > 22) {
            throw new Error('precision cannot be greater than 22');
        }
        else if (Math.round(precision) !== precision) {
            throw new Error('precision must be an integer');
        }
    }
    else {
        throw new Error('precision must be a number');
    }
    const latitudeRange = {
        min: -90,
        max: 90,
    };
    const longitudeRange = {
        min: -180,
        max: 180,
    };
    let hash = '';
    let hashVal = 0;
    let bits = 0;
    let even = 1;
    while (hash.length < precision) {
        const val = even ? location.longitude : location.latitude;
        const range = even ? longitudeRange : latitudeRange;
        const mid = (range.min + range.max) / 2;
        if (val > mid) {
            hashVal = (hashVal << 1) + 1;
            range.min = mid;
        }
        else {
            hashVal = (hashVal << 1) + 0;
            range.max = mid;
        }
        even = !even;
        if (bits < 4) {
            bits++;
        }
        else {
            bits = 0;
            hash += BASE32[hashVal];
            hashVal = 0;
        }
    }
    return hash;
}
function encodeGeoDocument(geopoint, geohash, document) {
    validateLocation(geopoint);
    validateGeohash(geohash);
    document.g = {
        geopoint,
        geohash,
    };
    return document;
}
function sanitizeSetOptions(options) {
    const clone = Object.assign({}, options);
    delete clone.customKey;
    return clone;
}
function encodeAddDocument(documentData, customKey) {
    if (Object.prototype.toString.call(documentData) !== '[object Object]') {
        throw new Error('document must be an object');
    }
    const geopoint = findGeoPoint(documentData, customKey);
    const geohash = encodeGeohash(geopoint);
    return encodeGeoDocument(geopoint, geohash, documentData);
}
function encodeSetDocument(documentData, options) {
    if (Object.prototype.toString.call(documentData) !== '[object Object]') {
        throw new Error('document must be an object');
    }
    const customKey = options ? options.customKey : null;
    const geopoint = findGeoPoint(documentData, customKey, options && (options.merge || !!options.mergeFields));
    if (geopoint) {
        const geohash = encodeGeohash(geopoint);
        return encodeGeoDocument(geopoint, geohash, documentData);
    }
    return documentData;
}
function encodeUpdateDocument(documentData, customKey) {
    if (Object.prototype.toString.call(documentData) !== '[object Object]') {
        throw new Error('document must be an object');
    }
    const geopoint = findGeoPoint(documentData, customKey, true);
    if (geopoint) {
        documentData.g = {
            geopoint,
            geohash: encodeGeohash(geopoint),
        };
    }
    return documentData;
}
function findGeoPoint(document, customKey, flag = false) {
    let error;
    let geopoint;
    if (!customKey) {
        geopoint = document['coordinates'];
    }
    else if (customKey in document) {
        geopoint = document[customKey];
    }
    else {
        const props = customKey.split('.');
        geopoint = document;
        for (const prop of props) {
            if (!(prop in geopoint)) {
                geopoint = document['coordinates'];
                break;
            }
            geopoint = geopoint[prop];
        }
    }
    if (!geopoint) {
        error = 'could not find GeoPoint';
    }
    if (geopoint && !validateLocation(geopoint, true)) {
        error = 'invalid GeoPoint';
    }
    if (error && !flag) {
        throw new Error('Invalid GeoFirestore document: ' + error);
    }
    return geopoint;
}
function generateGeoQueryDocumentSnapshot(snapshot, center) {
    const decoded = decodeGeoQueryDocumentSnapshotData(snapshot.data(), center);
    return Object.assign({ exists: snapshot.exists, id: snapshot.id }, decoded);
}
function geohashQueries(center, radius) {
    validateLocation(center);
    const queryBits = Math.max(1, boundingBoxBits(center, radius));
    const geohashPrecision = Math.ceil(queryBits / BITS_PER_CHAR);
    const coordinates = boundingBoxCoordinates(center, radius);
    const queries = coordinates.map(coordinate => {
        return geohashQuery(encodeGeohash(coordinate, geohashPrecision), queryBits);
    });
    return queries.filter((query, index) => {
        return !queries.some((other, otherIndex) => {
            return (index > otherIndex && query[0] === other[0] && query[1] === other[1]);
        });
    });
}
function geohashQuery(geohash, bits) {
    validateGeohash(geohash);
    const precision = Math.ceil(bits / BITS_PER_CHAR);
    if (geohash.length < precision) {
        return [geohash, geohash + '~'];
    }
    const ghash = geohash.substring(0, precision);
    const base = ghash.substring(0, ghash.length - 1);
    const lastValue = BASE32.indexOf(ghash.charAt(ghash.length - 1));
    const significantBits = bits - base.length * BITS_PER_CHAR;
    const unusedBits = BITS_PER_CHAR - significantBits;
    const startValue = (lastValue >> unusedBits) << unusedBits;
    const endValue = startValue + (1 << unusedBits);
    if (endValue > 31) {
        return [base + BASE32[startValue], base + '~'];
    }
    else {
        return [base + BASE32[startValue], base + BASE32[endValue]];
    }
}
function latitudeBitsForResolution(resolution) {
    return Math.min(log2(EARTH_MERI_CIRCUMFERENCE / 2 / resolution), MAXIMUM_BITS_PRECISION);
}
function log2(x) {
    return Math.log(x) / Math.log(2);
}
function longitudeBitsForResolution(resolution, latitude) {
    const degs = metersToLongitudeDegrees(resolution, latitude);
    return Math.abs(degs) > 0.000001 ? Math.max(1, log2(360 / degs)) : 1;
}
function metersToLongitudeDegrees(distance, latitude) {
    const radians = degreesToRadians(latitude);
    const num = (Math.cos(radians) * EARTH_EQ_RADIUS * Math.PI) / 180;
    const denom = 1 / Math.sqrt(1 - E2 * Math.sin(radians) * Math.sin(radians));
    const deltaDeg = num * denom;
    if (deltaDeg < EPSILON) {
        return distance > 0 ? 360 : 0;
    }
    else {
        return Math.min(360, distance / deltaDeg);
    }
}
function toGeoPoint(latitude, longitude) {
    const fakeGeoPoint = { latitude, longitude };
    validateLocation(fakeGeoPoint);
    return fakeGeoPoint;
}
function validateGeoDocument(documentData, flag = false) {
    let error;
    if (!documentData) {
        error = 'no document found';
    }
    else if ('g' in documentData) {
        error = !validateGeohash(documentData.g.geohash, true)
            ? 'invalid geohash on object'
            : null;
        error = !validateLocation(documentData.g.geopoint, true)
            ? 'invalid location on object'
            : error;
    }
    else {
        error = 'no `g` field found in object';
    }
    if (error && !flag) {
        throw new Error('Invalid GeoFirestore object: ' + error);
    }
    else {
        return !error;
    }
}
function validateGeohash(geohash, flag = false) {
    let error;
    if (typeof geohash !== 'string') {
        error = 'geohash must be a string';
    }
    else if (geohash.length === 0) {
        error = 'geohash cannot be the empty string';
    }
    else {
        for (const letter of geohash) {
            if (BASE32.indexOf(letter) === -1) {
                error = "geohash cannot contain '" + letter + "'";
            }
        }
    }
    if (typeof error !== 'undefined' && !flag) {
        throw new Error("Invalid GeoFire geohash '" + geohash + "': " + error);
    }
    else {
        return !error;
    }
}
function validateLimit(limit, flag = false) {
    let error;
    if (typeof limit !== 'number' || isNaN(limit)) {
        error = 'limit must be a number';
    }
    else if (limit < 0) {
        error = 'limit must be greater than or equal to 0';
    }
    if (typeof error !== 'undefined' && !flag) {
        throw new Error(error);
    }
    else {
        return !error;
    }
}
function validateLocation(location, flag = false) {
    let error;
    if (!location) {
        error = 'GeoPoint must exist';
    }
    else if (typeof location.latitude === 'undefined') {
        error = 'latitude must exist on GeoPoint';
    }
    else if (typeof location.longitude === 'undefined') {
        error = 'longitude must exist on GeoPoint';
    }
    else {
        const latitude = location.latitude;
        const longitude = location.longitude;
        if (typeof latitude !== 'number' || isNaN(latitude)) {
            error = 'latitude must be a number';
        }
        else if (latitude < -90 || latitude > 90) {
            error = 'latitude must be within the range [-90, 90]';
        }
        else if (typeof longitude !== 'number' || isNaN(longitude)) {
            error = 'longitude must be a number';
        }
        else if (longitude < -180 || longitude > 180) {
            error = 'longitude must be within the range [-180, 180]';
        }
    }
    if (typeof error !== 'undefined' && !flag) {
        throw new Error('Invalid location: ' + error);
    }
    else {
        return !error;
    }
}
function validateQueryCriteria(newQueryCriteria, requireCenterAndRadius = false) {
    if (typeof newQueryCriteria !== 'object') {
        throw new Error('QueryCriteria must be an object');
    }
    else if (typeof newQueryCriteria.center === 'undefined' &&
        typeof newQueryCriteria.radius === 'undefined') {
        throw new Error('radius and/or center must be specified');
    }
    else if (requireCenterAndRadius &&
        (typeof newQueryCriteria.center === 'undefined' ||
            typeof newQueryCriteria.radius === 'undefined')) {
        throw new Error('QueryCriteria for a new query must contain both a center and a radius');
    }
    const keys = Object.keys(newQueryCriteria);
    for (const key of keys) {
        if (!['center', 'radius', 'limit'].includes(key)) {
            throw new Error("Unexpected attribute '" + key + "' found in query criteria");
        }
    }
    if (typeof newQueryCriteria.center !== 'undefined') {
        validateLocation(newQueryCriteria.center);
    }
    if (typeof newQueryCriteria.radius !== 'undefined') {
        if (typeof newQueryCriteria.radius !== 'number' ||
            isNaN(newQueryCriteria.radius)) {
            throw new Error('radius must be a number');
        }
        else if (newQueryCriteria.radius < 0) {
            throw new Error('radius must be greater than or equal to 0');
        }
    }
    if (typeof newQueryCriteria.limit !== 'undefined') {
        validateLimit(newQueryCriteria.limit);
    }
}
function wrapLongitude(longitude) {
    if (longitude <= 180 && longitude >= -180) {
        return longitude;
    }
    const adjusted = longitude + 180;
    if (adjusted > 0) {
        return (adjusted % 360) - 180;
    }
    else {
        return 180 - (-adjusted % 360);
    }
}

class GeoDocumentSnapshot {
    constructor(_snapshot) {
        this._snapshot = _snapshot;
        if (Object.prototype.toString.call(_snapshot) !== '[object Object]') {
            throw new Error('DocumentSnapshot must be an instance of a Firestore DocumentSnapshot');
        }
        this._isWeb =
            Object.prototype.toString.call(_snapshot.ref.firestore
                .enablePersistence) === '[object Function]';
    }
    get native() {
        return this._snapshot;
    }
    get exists() {
        return this._snapshot.exists;
    }
    get id() {
        return this._snapshot.id;
    }
    get ref() {
        return new GeoDocumentReference(this._snapshot.ref);
    }
    data(options) {
        const documentData = this._isWeb && options
            ? this._snapshot.data(options)
            : this._snapshot.data();
        return documentData;
    }
    get(fieldPath, options) {
        return this._isWeb && options
            ? this._snapshot.get(fieldPath, options)
            : this._snapshot.get(fieldPath);
    }
    isEqual(other) {
        const ref = other instanceof GeoDocumentSnapshot ? other['_snapshot'] : other;
        return this._snapshot.isEqual(ref);
    }
}

class GeoWriteBatch {
    constructor(_writeBatch) {
        this._writeBatch = _writeBatch;
        if (Object.prototype.toString.call(_writeBatch) !== '[object Object]') {
            throw new Error('WriteBatch must be an instance of a Firestore WriteBatch');
        }
    }
    get native() {
        return this._writeBatch;
    }
    set(documentRef, documentData, options) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._writeBatch.set(ref, encodeSetDocument(documentData, options), sanitizeSetOptions(options));
        return this;
    }
    update(documentRef, data, customKey) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._writeBatch.update(ref, encodeUpdateDocument(data, customKey));
        return this;
    }
    delete(documentRef) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._writeBatch.delete(ref);
        return this;
    }
    commit() {
        return this._writeBatch.commit();
    }
}

class GeoFirestore {
    constructor(_firestore) {
        this._firestore = _firestore;
        if (Object.prototype.toString.call(_firestore) !== '[object Object]') {
            throw new Error('Firestore must be an instance of Firestore');
        }
    }
    get native() {
        return this._firestore;
    }
    batch() {
        return new GeoWriteBatch(this._firestore.batch());
    }
    collection(collectionPath) {
        return new GeoCollectionReference(this._firestore.collection(collectionPath));
    }
    runTransaction(updateFunction) {
        return this
            ._firestore.runTransaction(updateFunction);
    }
}

class GeoDocumentReference {
    constructor(_document) {
        this._document = _document;
        if (Object.prototype.toString.call(_document) !== '[object Object]') {
            throw new Error('DocumentReference must be an instance of a Firestore DocumentReference');
        }
        this._isWeb =
            Object.prototype.toString.call(_document.firestore
                .enablePersistence) === '[object Function]';
    }
    get native() {
        return this._document;
    }
    get id() {
        return this._document.id;
    }
    get firestore() {
        return new GeoFirestore(this._document.firestore);
    }
    get onSnapshot() {
        return (onNext, onError = () => { }) => {
            return this
                ._document.onSnapshot(snapshot => onNext(new GeoDocumentSnapshot(snapshot)), error => onError(error));
        };
    }
    get parent() {
        return new GeoCollectionReference(this._document.parent);
    }
    get path() {
        return this._document.path;
    }
    collection(collectionPath) {
        return new GeoCollectionReference(this._document.collection(collectionPath));
    }
    delete() {
        return this._document
            .delete()
            .then(() => null);
    }
    get(options = { source: 'default' }) {
        const get = this._isWeb
            ? this._document.get(options)
            : this._document.get();
        return get.then(snapshot => new GeoDocumentSnapshot(snapshot));
    }
    isEqual(other) {
        const ref = other instanceof GeoDocumentReference ? other['_document'] : other;
        return this._document.isEqual(ref);
    }
    set(documentData, options) {
        return this._document
            .set(encodeSetDocument(documentData, options), sanitizeSetOptions(options))
            .then(() => null);
    }
    update(data, customKey) {
        return this._document
            .update(encodeUpdateDocument(data, customKey))
            .then(() => null);
    }
}

class GeoQuerySnapshot {
    constructor(_querySnapshot, _center) {
        this._querySnapshot = _querySnapshot;
        this._center = _center;
        if (_center) {
            validateLocation(_center);
        }
        this._docs = _querySnapshot.docs.map((snapshot) => generateGeoQueryDocumentSnapshot(snapshot, _center));
    }
    get native() {
        return this._querySnapshot;
    }
    get docs() {
        return this._docs;
    }
    get size() {
        return this._docs.length;
    }
    get empty() {
        return !this._docs.length;
    }
    docChanges() {
        const docChanges = Array.isArray(this._querySnapshot.docChanges)
            ? this._querySnapshot
                .docChanges
            : this._querySnapshot.docChanges();
        return docChanges.map((change) => {
            return {
                doc: generateGeoQueryDocumentSnapshot(change.doc, this._center),
                newIndex: change.newIndex,
                oldIndex: change.oldIndex,
                type: change.type,
            };
        });
    }
    forEach(callback, thisArg) {
        this.docs.forEach(callback, thisArg);
    }
}

class GeoJoinerGet {
    constructor(snapshots, _queryCriteria) {
        this._queryCriteria = _queryCriteria;
        this._docs = new Map();
        validateQueryCriteria(_queryCriteria);
        snapshots.forEach((snapshot) => {
            snapshot.docs.forEach(doc => {
                const distance = calculateDistance(this._queryCriteria.center, doc.data().g.geopoint);
                if (this._queryCriteria.radius >= distance) {
                    this._docs.set(doc.id, doc);
                }
            });
        });
        if (this._queryCriteria.limit &&
            this._docs.size > this._queryCriteria.limit) {
            const arrayToLimit = Array.from(this._docs.values())
                .map(doc => {
                return {
                    distance: calculateDistance(this._queryCriteria.center, doc.data().g.geopoint),
                    id: doc.id,
                };
            })
                .sort((a, b) => a.distance - b.distance);
            for (let i = this._queryCriteria.limit; i < arrayToLimit.length; i++) {
                this._docs.delete(arrayToLimit[i].id);
            }
        }
    }
    getGeoQuerySnapshot() {
        const docs = Array.from(this._docs.values());
        return new GeoQuerySnapshot({
            docs,
            docChanges: () => docs.map((doc, index) => {
                return { doc, newIndex: index, oldIndex: -1, type: 'added' };
            }),
        }, this._queryCriteria.center);
    }
}

class GeoJoinerOnSnapshot {
    constructor(_queries, _queryCriteria, _onNext, _onError = () => { }) {
        this._queries = _queries;
        this._queryCriteria = _queryCriteria;
        this._onNext = _onNext;
        this._onError = _onError;
        this._docs = new Map();
        this._firstRoundResolved = false;
        this._firstEmitted = false;
        this._newValues = false;
        this._subscriptions = [];
        this._queriesResolved = [];
        validateQueryCriteria(_queryCriteria);
        this._queriesResolved = new Array(_queries.length).fill(0);
        _queries.forEach((value, index) => {
            const subscription = value.onSnapshot(snapshot => this._processSnapshot(snapshot, index), error => (this._error = error));
            this._subscriptions.push(subscription);
        });
        this._interval = setInterval(() => this._emit(), 100);
    }
    unsubscribe() {
        return () => {
            clearInterval(this._interval);
            this._subscriptions.forEach(subscription => subscription());
        };
    }
    _next() {
        if (this._queryCriteria.limit &&
            this._docs.size > this._queryCriteria.limit) {
            const arrayToLimit = Array.from(this._docs.values()).sort((a, b) => a.distance - b.distance);
            for (let i = this._queryCriteria.limit; i < arrayToLimit.length; i++) {
                if (arrayToLimit[i].emitted) {
                    const result = {
                        change: Object.assign({}, arrayToLimit[i].change),
                        distance: arrayToLimit[i].distance,
                        emitted: arrayToLimit[i].emitted,
                    };
                    result.change.type = 'removed';
                    this._docs.set(result.change.doc.id, result);
                }
                else {
                    this._docs.delete(arrayToLimit[i].change.doc.id);
                }
            }
        }
        let deductIndexBy = 0;
        const docChanges = Array.from(this._docs.values()).map((value, index) => {
            const result = {
                type: value.change.type,
                doc: value.change.doc,
                oldIndex: value.emitted ? value.change.newIndex : -1,
                newIndex: value.change.type !== 'removed' ? index - deductIndexBy : -1,
            };
            if (result.type === 'removed') {
                deductIndexBy--;
                this._docs.delete(result.doc.id);
            }
            else {
                this._docs.set(result.doc.id, {
                    change: result,
                    distance: value.distance,
                    emitted: true,
                });
            }
            return result;
        });
        const docs = docChanges.reduce((filtered, change) => {
            if (change.newIndex >= 0) {
                filtered.push(change.doc);
            }
            else {
                this._docs.delete(change.doc.id);
            }
            return filtered;
        }, []);
        this._firstEmitted = true;
        this._onNext(new GeoQuerySnapshot({
            docs,
            docChanges: () => docChanges.reduce((reduced, change) => {
                if (change.oldIndex === -1 || change.type !== 'added') {
                    reduced.push(change);
                }
                return reduced;
            }, []),
        }, this._queryCriteria.center));
    }
    _emit() {
        if (this._error) {
            this._onError(this._error);
            this.unsubscribe()();
        }
        else if (this._newValues && this._firstRoundResolved) {
            this._newValues = false;
            this._next();
        }
        else if (!this._firstRoundResolved) {
            this._firstRoundResolved =
                this._queriesResolved.reduce((a, b) => a + b, 0) ===
                    this._queries.length;
        }
    }
    _processSnapshot(snapshot, index) {
        const docChanges = Array.isArray(snapshot.docChanges)
            ? snapshot.docChanges
            : snapshot.docChanges();
        if (!this._firstRoundResolved)
            this._queriesResolved[index] = 1;
        if (docChanges.length) {
            docChanges.forEach(change => {
                const docData = change.doc.data();
                const geopoint = validateGeoDocument(docData, true)
                    ? docData.g.geopoint
                    : null;
                const distance = geopoint
                    ? calculateDistance(this._queryCriteria.center, geopoint)
                    : null;
                const id = change.doc.id;
                const fromMap = this._docs.get(id);
                const doc = {
                    change: {
                        doc: change.doc,
                        oldIndex: fromMap && this._firstEmitted ? fromMap.change.oldIndex : -1,
                        newIndex: fromMap && this._firstEmitted ? fromMap.change.newIndex : -1,
                        type: fromMap && this._firstEmitted ? change.type : 'added',
                    },
                    distance,
                    emitted: this._firstEmitted ? !!fromMap : false,
                };
                if (this._queryCriteria.radius >= distance) {
                    if (!fromMap && doc.change.type === 'removed')
                        return;
                    if (!fromMap && doc.change.type === 'modified')
                        doc.change.type = 'added';
                    this._newValues = true;
                    this._docs.set(id, doc);
                }
                else if (fromMap) {
                    doc.change.type = 'removed';
                    this._newValues = true;
                    this._docs.set(id, doc);
                }
                else if (!fromMap && !this._firstRoundResolved) {
                    this._newValues = true;
                }
            });
        }
        else if (!this._firstRoundResolved) {
            this._newValues = true;
        }
    }
}

class GeoQuery {
    constructor(_query, queryCriteria) {
        this._query = _query;
        if (Object.prototype.toString.call(_query) !== '[object Object]') {
            throw new Error('Query must be an instance of a Firestore Query');
        }
        this._isWeb =
            Object.prototype.toString.call(_query.firestore
                .enablePersistence) === '[object Function]';
        if (queryCriteria) {
            if (typeof queryCriteria.limit === 'number') {
                this._limit = queryCriteria.limit;
            }
            if (queryCriteria.center && typeof queryCriteria.radius === 'number') {
                validateQueryCriteria(queryCriteria);
                this._center = queryCriteria.center;
                this._radius = queryCriteria.radius;
            }
        }
    }
    get native() {
        return this._query;
    }
    get firestore() {
        return new GeoFirestore(this._query.firestore);
    }
    get onSnapshot() {
        return (onNext, onError = () => { }) => {
            if (this._center && typeof this._radius === 'number') {
                return new GeoJoinerOnSnapshot(this._generateQuery(), this._queryCriteria, onNext, onError).unsubscribe();
            }
            else {
                const query = this._limit
                    ? this._query.limit(this._limit)
                    : this._query;
                return query.onSnapshot(snapshot => onNext(new GeoQuerySnapshot(snapshot)), onError);
            }
        };
    }
    get(options = { source: 'default' }) {
        if (this._center && typeof this._radius === 'number') {
            const queries = this._generateQuery().map(query => this._isWeb ? query.get(options) : query.get());
            return Promise.all(queries).then(value => new GeoJoinerGet(value, this._queryCriteria).getGeoQuerySnapshot());
        }
        else {
            const query = this._limit ? this._query.limit(this._limit) : this._query;
            const promise = this._isWeb
                ? query.get(options)
                : query.get();
            return promise.then(snapshot => new GeoQuerySnapshot(snapshot));
        }
    }
    limit(limit) {
        validateLimit(limit);
        this._limit = limit;
        return new GeoQuery(this._query, this._queryCriteria);
    }
    near(newGeoQueryCriteria) {
        validateQueryCriteria(newGeoQueryCriteria, true);
        this._center = newGeoQueryCriteria.center;
        this._radius = newGeoQueryCriteria.radius;
        return new GeoQuery(this._query, this._queryCriteria);
    }
    where(fieldPath, opStr, value) {
        return new GeoQuery(this._query.where(fieldPath, opStr, value), this._queryCriteria);
    }
    _generateQuery() {
        let geohashesToQuery = geohashQueries(this._center, this._radius * 1000).map(this._queryToString);
        geohashesToQuery = geohashesToQuery.filter((geohash, i) => geohashesToQuery.indexOf(geohash) === i);
        return geohashesToQuery.map((toQueryStr) => {
            const query = this._stringToQuery(toQueryStr);
            return this._query
                .orderBy('g.geohash')
                .startAt(query[0])
                .endAt(query[1]);
        });
    }
    get _queryCriteria() {
        return {
            center: this._center,
            limit: this._limit,
            radius: this._radius,
        };
    }
    _stringToQuery(str) {
        const decoded = str.split(':');
        if (decoded.length !== 2) {
            throw new Error('Invalid internal state! Not a valid geohash query: ' + str);
        }
        return decoded;
    }
    _queryToString(query) {
        if (query.length !== 2) {
            throw new Error('Not a valid geohash query: ' + query);
        }
        return query[0] + ':' + query[1];
    }
}

class GeoCollectionReference extends GeoQuery {
    constructor(_collection) {
        super(_collection);
        this._collection = _collection;
    }
    get native() {
        return this._collection;
    }
    get id() {
        return this._collection.id;
    }
    get parent() {
        return this._collection.parent
            ? new GeoDocumentReference(this._collection.parent)
            : null;
    }
    get path() {
        return this._collection.path;
    }
    add(documentData, customKey) {
        return this._collection
            .add(encodeAddDocument(documentData, customKey))
            .then(doc => new GeoDocumentReference(doc));
    }
    doc(documentPath) {
        return documentPath
            ? new GeoDocumentReference(this._collection.doc(documentPath))
            : new GeoDocumentReference(this._collection.doc());
    }
}

class GeoTransaction {
    constructor(_transaction) {
        this._transaction = _transaction;
        if (Object.prototype.toString.call(_transaction) !== '[object Object]') {
            throw new Error('Transaction must be an instance of a Firestore Transaction');
        }
    }
    get native() {
        return this._transaction;
    }
    delete(documentRef) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._transaction.delete(ref);
        return this;
    }
    get(documentRef) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        return this._transaction
            .get(ref)
            .then((snpashot) => new GeoDocumentSnapshot(snpashot));
    }
    set(documentRef, documentData, options) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._transaction.set(ref, encodeSetDocument(documentData, options), sanitizeSetOptions(options));
        return this;
    }
    update(documentRef, data, customKey) {
        const ref = documentRef instanceof GeoDocumentReference
            ? documentRef['_document']
            : documentRef;
        this._transaction.update(ref, encodeUpdateDocument(data, customKey));
        return this;
    }
}

export { GeoCollectionReference, GeoDocumentReference, GeoDocumentSnapshot, GeoFirestore, GeoQuery, GeoQuerySnapshot, GeoTransaction, GeoWriteBatch };
